# SimpleAPI

## Подключение

```composer require digitalstars/simple-api:dev-testing```

## В общих словах

Библиотека представляет собой удобный интерфейс для конструирования обработчиков запросов API.

## Использование, быстрый старт

### Быстрое создание обработчика запросов в одном файле

Быстрый пример файла User.php. Который будет обрабатывать GET/POST запросы.

```php
require_once 'vendor/autoload.php';

use \DigitalStars\SimpleAPI\Module;

class User extends Module {
    public function getUser(int $id) {
        return ['user' => 'user' . $id];
    }
    
    public function getAllUsers(int $page = 1, bool $is_admin = false) {
        return ['users' => ['user1', 'user2']];
    }
}

User::create()->run();
```

На примере выше, создаётся класс User. Публичные методы этого класса будут обрабатывать запросы, названия методов
соответствуют параметру 'method' в запросе. Остальные параметры запроса будут валидироваться (если указаны типы в
методе)
и передаваться в метод. *Параметры запроса должны быть без знака $*

Метод внутри модуля поддерживает:

- Типизированные параметры (int, double, bool, array, string) **Будут дополнительно отвалидированы библиотекой
  ** [Подробнее тут](#валидация-входных-параметров)
- Значения по умолчанию для параметров

Объявленный класс (модуль) содержит:

- Публичные методы, которые будут обрабатывать запросы
- Приватное свойство $api **(доступ из методов $this->api)**, в котором хранится объект API. С помощью него можно
  управлять поведением API
  (например, дополнительно валидировать параметры, добавлять таймеры, возвращать ошибку или отправить данные клиенту без
  завершения скрипта)

`User::create()->run();` - создаёт объект User и запускает обработку запроса.

> **Важно! Каждый модуль обработчик (класс) должен быть в своём одноимённом файле.**

### Несколько файлов, обработчиков запросов

Допустим у нас есть два файла: User.php и Info.php. В файле User.php находится обработчик запросов для работы с
пользователями, а в файле Info.php - обработчик запросов для работы с информацией.
И нам понадобилось вызвать метод файла User.php из файла Info.php.

User.php:

```php
require_once 'vendor/autoload.php';

use \DigitalStars\SimpleAPI\Module;

class User extends Module {
    public function getUser(int $id) {
        if ($id < 0) // Если id меньше 0, то возвращаем ошибку (пример обработки ошибки)
            $this->api->field_invalid('id')->validate();
        return ['user' => 'user' . $id, 'name' => 'User_name'];
    }
}

User::create()->run();
```

Info.php:

```php
require_once 'vendor/autoload.php';
require_once 'User.php';

use \DigitalStars\SimpleAPI\Module;

class Info extends Module {
    public function getInfo(int $user_id, int $type = 1) {
        try {
            $user_data = User::create()->getUser($user_id);
        } catch (\DigitalStars\SimpleAPI\Exception $e) {
            $user_data = 'user_is_invalid';
        }
        return ['info_type' => 'info' . $type, 'user' => $user_data];
    }
}

Info::create()->run();
```

Теперь при запросе метода getInfo из файла Info.php, будет вызван метод getUser из файла User.php.

Но что, если внутри метода getUser произойдёт ошибка?

В этом случае, будет вызвано исключение \DigitalStars\SimpleAPI\Exception. Исключение будет обработано в методе getInfo.
Если же исключение не будет обработано, то скрипт завершится, вернёт код ответа 501 и сообщение об ошибке.

Далее по документации мы рассмотрим методы и свойства объекта API.

## Свойства API

### data: array

Массив параметров запроса. В него попадают все параметры, которые пришли в запросе. Включая параметры GET, POST и JSON.

> В массиве будут вообще все параметры, которые пришли в запросе. Включая параметры, которые не были указаны в методе.

### answer: array|string

Данные, которые будут отправлены клиенту. Может быть массивом или строкой. По умолчанию пустой массив.

> Внимание! Если по завершению метода свойство answer будет содержать не пустое значение, то оно будет отправлено
> клиенту, данные возвращаемые методом будут проигнорированы.

### error_func: ?callable

Функция, которая будет вызвана при возникновении ошибки в любом из методов. По умолчанию null.

### is_save_error: bool

Если true, то при возникновении ошибки, данные об ошибке будут сохранены в файле ошибок. По умолчанию false.

### is_ignore_destruct: bool

Если true, то при завершении скрипта, данные ответа не будут отправлены клиенту. По умолчанию false.
> Может быть полезно во время дебага, чтобы не отправлять клиенту недоработанный ответ. Или если нужно отправить ответ
> вручную с особыми заголовками.

### is_ignore_json_header: bool

Если true, то заголовок ответа не будет содержать "Content-Type: application/json", а также ответ не будет приводится к
JSON. По умолчанию false.

### is_log_time: bool

Если true, то в заголовке ответа будет добавлено поле "Server-Timing" с таймингами выполнения скрипта, методов, и
кастомными таймерами. По умолчанию false.
Подробнее в разделе [Тайминги](#методы-для-таймингов)

### store: array

Массив, в который можно сохранять данные, чтобы использовать их в других методах или даже модулях (т.к. объект API общий
для всех). По умолчанию пустой массив.

## Основные методы

### Получить экземпляр API.

Подразумевается, что API будет использоваться из методов модуля. Он там заранее инициализирован и находится в свойстве
$this->api.
Кроме того, он является общим для всех модулей.

Однако, при обработке крайних случаев, можно получить экземпляр API через статический метод getApi.

```php

#### Пример

```php
$api = \DigitalStars\SimpleAPI\API::getApi();
```

### close(): void

Закрывает соединение с клиентом. После вызова этого метода, данные ответа будут отправлены клиенту, но скрипт продолжит
своё выполнение. Полезно, когда нужно отправить ответ клиенту и продолжить выполнение скрипта.

> **Внимание! После вызова этого метода, нельзя изменять данные ответа.**

> С помощью этого метода можно ускорить API, перенося сложные вычисления после отправки ответа клиенту.

#### Пример

```php
class User extends \DigitalStars\SimpleAPI\Module {
    public function getUser(int $id) {
        $this->api->answer = ['user' => 'user' . $id, 'name' => 'User_name'];
        
        $this->api->close();
        
        // Следующий код будет выполнен после отправки ответа клиенту
        // ... Какие-то сложные вычисления
    }
}

User::create()->run();
```

### run(Module $module, \ReflectionClass $reflection = null): void

Запускает обработку запроса модулем. Обычно этот метод вызывать не нужно, т.к. его вызывает сам модуль при обработке.

Принимает параметры:

- $module - объект модуля
- $reflection - объект ReflectionClass модуля *(не обязательно)*

## Методы информационные

### getModule(): string

Возвращает имя вызванного модуля (если выполняется дочерний модуль, то имя модуля с которого началось выполнение)

### getMethod(): string

Возвращает имя вызванного метода, с которого началось выполнение

## Методы особых случаев

### addBeforeDestructFunc(callable $func): SimpleAPI

Добавляет функцию, которая будет вызвана перед отправкой ответа клиенту. В функцию передаётся объект API.
Полезно, если нужно выполнить какие-то действия перед отправкой ответа клиенту. (добавить какой-то заголовок, изменить
данные ответа)

> **Внимание!** При повторном вызове этого метода, будут добавлены новые функции, которые будут вызваны в порядке
> добавления.

### addAfterDestructFunc(callable $func): SimpleAPI

Добавляет функцию, которая будет вызвана после отправки ответа клиенту. В функцию передаётся объект API.
Полезно, если нужно выполнить какие-то действия после отправки ответа клиенту. (например залогировать запрос или ответ)

> **Внимание!** При повторном вызове этого метода, будут добавлены новые функции, которые будут вызваны в порядке
> добавления.

> Главное отличие от addBeforeDestructFunc в том, что эта функция будет вызвана после отправки ответа клиенту, но до
> завершения скрипта.
> То есть в ней нельзя менять данные ответа, но можно выполнить какие-то 'тяжёлые' действия.

## Валидация входных параметров

При возвращении ошибки, автоматически статус ответа будет 501.

Существуют такие ошибки по умолчанию:

- `error_fields: ` + перечисление названий параметров, которые не прошли валидацию (например, "error_fields: id,name")
- `missed method` - если не указан метод
- `missed params` - если не указан один или несколько обязательных параметров
- `data is empty` - если нет входных параметров
- `json invalid` - ошибка при декодировании JSON (если на вход переданы данные, похожие на JSON, но не являющиеся JSON)

### Типы параметров

Библиотека осуществляет дополнительную валидацию входных параметров. Поддерживаются следующие типы данных:

- int - целое число (или строка с целым числом)
- double - число с плавающей точкой (или строка с числом с плавающей точкой)
- bool - логическое значение (или строка "true" или "false") (любое значение, которое приводится к true или false)
- array - массив
- string - строка, с экранированием HTML спецсимволов (htmlspecialchars)
- без типа данных - любой тип данных, без валидации (по умолчанию)

> Кроме того, в параметрах можно указать необязательные параметры, добавив для них значения по умолчанию.

> **Внимание! ** Не обязательные параметры должны быть указаны в конце списка параметров, иначе они будут восприняты как
> обязательные.

#### Примеры

```php
class User extends \DigitalStars\SimpleAPI\Module {
    public function getUser(int $id, string $name, bool $is_admin, bool $is_new_version = false) {
        return ['user' => 'user' . $id, 'name' => $name, 'is_admin' => $is_admin, 'is_new_version' => $is_new_version];
    }
}

User::create()->run();
```

Данный метод будет обрабатывать запросы с параметром "method" равным "getUser" и параметрами "id" типа int, "name" типа
string, "is_admin" типа bool и "is_new_version" типа bool. Параметр "is_new_version" является необязательным (значение
по умолчанию false).

#### Возвращаемое значение

Если параметры не валидны, то будет возвращена ошибка: "error" => "error_fields: " + перечисление названий параметров,
которые не прошли валидацию.

## Методы для валидации входных параметров

Для обработки крайних случаев, можно использовать методы для валидации входных параметров вручную.

### valid_int(string $field): SimpleAPI

Валидирует параметр как целое число. Если параметр не является целым числом, то добавляет ошибку в ответ.

### valid_double(string $field): SimpleAPI

Валидирует параметр как число с плавающей точкой. Если параметр не является числом с плавающей точкой, то добавляет
ошибку в ответ.

### valid_bool(string $field): SimpleAPI

Валидирует параметр как логическое значение. Если параметр не является логическим значением, то добавляет ошибку в
ответ.

### valid_array(string $field): SimpleAPI

Валидирует параметр как массив. Если параметр не является массивом, то добавляет ошибку в ответ.

### valid_preg(string $preg, string $field): SimpleAPI

Валидирует параметр с помощью регулярного выражения. Если параметр не соответствует регулярному выражению, то добавляет
ошибку в ответ.

### field_invalid(string $field): SimpleAPI

Добавляет ошибку в ответ, что параметр не прошёл валидацию.

### validate(bool $is_send_exception = true): bool

Проверяет, если хотя бы один метод валидации вернул ошибку, то возвращает false. Иначе true. Кроме того, если параметр
$is_send_exception равен true (значение по умолчанию), то при ошибке будет добавлена ошибка в ответ и выполнение скрипта
будет прервано.

### error(string $text): void

Добавляет ошибку в ответ и немедленно завершает выполнение скрипта. $text - текст ошибки.

Текст ошибки будет добавлен в ответ в поле "error".

> Если точнее, то будет сгенерировано исключение \DigitalStars\SimpleAPI\Exception с текстом ошибки. Если
> его не обработать, то скрипт завершится с кодом ответа 501 и сообщением об ошибке.
>
> Полезно тем, что можно вызывать методы вручную, и при возникновении ошибки, обрабатывать её.

#### Примеры

```php
class User extends \DigitalStars\SimpleAPI\Module {
    public function getUser(int $id, string $name, bool $is_admin)
        $this->api->valid_preg('/^[a-zA-Z0-9_]+$/', 'name');
        $this->api->validate();
    
        return ['user' => 'user' . $id, 'name' => $name, 'is_admin' => $is_admin];
    }
}

User::create()->run();
```

Данный метод будет обрабатывать запросы с параметром "method" равным "getUser" и параметрами "id" типа int, "name" типа
string, "is_admin" типа bool. Параметр "name" будет валидирован с помощью регулярного выражения. Если параметры не
валидны, то будет возвращена ошибка: "error" => "error_fields: " + названия невалидных полей.

Например, запрос:

```json
{
  "method": "getUser",
  "id": 1,
  "name": "User_123",
  "is_admin": true
}
```

Вернёт:

```json
{
  "user": "user1",
  "name": "User_123",
  "is_admin": true
}
```

Запрос:

```json
{
  "module": "getUser",
  "id": 1,
  "name": "User_123!"
}
```

Вернёт:

```json
{
  "error": "error_fields: name"
}
```

Запрос:

```json
{
  "module": "getUser",
  "id": "eee",
  "name": "User_123!!!!",
  "is_admin": true
}
```

Вернёт:

```json
{
  "error": "error_fields: id"
}
```

> Обратите внимание, что параметра `name` нет в списке ошибок, потому что ошибка валидации параметра `id` прерывает
> выполнение.

## Методы для таймингов

Библиотека поддеоживает тайминги выполнения скрипта, метода и кастомные таймеры. Тайминги можно использовать для
оптимизации и дебага.

Тайминги добавляются в заголовок ответа "Server-Timing" в формате "api;dur=123.45;desc=Script, ...." (если
свойство `is_log_time=true`).

Кроме того, тайминги можно получить через метод getTimerLog().

По умолчанию есть такие тайминги:

- Method - время выполнения метода к которому пришёл запрос
- Script - время выполнения всего скрипта
- before_destruct_func_1, before_destruct_func_2, ... - время выполнения функций, добавленных через
  addBeforeDestructFunc

### getTimeStart(): float

Возвращает время начала выполнения скрипта (время в секундах с плавающей точкой)

### logTimer($name, $time_duration): void

Добавляет кастомный таймер. $name - название таймера, $time_duration - время выполнения таймера в секундах с плавающей

### timerStart(): float

Возвращает время начала выполнения таймера (время в секундах с плавающей точкой) (microtime(true))

### logTimerStop(string $name, float $time_start): float

Добавляет кастомный таймер. $name - название таймера, $time_start - время начала выполнения таймера (время в секундах с
плавающей точкой) (microtime(true))

Возвращает время выполнения таймера в секундах с плавающей точкой

### getTimerLog(): array

Возвращает массив с таймингами выполнения скрипта, методов и кастомными таймерами

Вид в котором они возвращаются:

```php
[
    ['Module', 0.123],
    ['Script', 0.456],
    ['before_destruct_func_1', 0.789],
    ['subModule:user:getUser', 0.123],
    ['custom_timer_1', 0.123],
    ...
]
```
