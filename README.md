# SimpleAPI

## Подключение

```composer require digitalstars/simple-api:dev-testing```

## В общих словах

Библиотека представляет собой удобный интерфейс для конструирования обработчиков запросов API.

## Использование

Библиотеку можно использовать как для однофайлового (простого) API. Так и для более сложного варианта, когда API состоит
из
нескольких файлов.

### Простой вариант

Тут всё в принципе понятно. Создаём объект класса SimpleAPI и добавляем модули.

```php
require_once 'vendor/autoload.php';

$api = new \DigitalStars\SimpleAPI\SimpleAPI();

$api->module('getUsers', [], function() {
    return ['users' => ['user1', 'user2']];
});
```

### Сложный вариант

В этом случае, создаём объект класса SimpleAPI только один раз, в отдельном файле. В каждом файле, который будет
обрабатывать
запросы, подключаем этот объект и добавляем модули.

> **Важно! В каждом файле с модулями, перед самими модулями должна быть строка: `$api->root_filename(__FILE__);`**

Файл init.php:

```php
require_once 'vendor/autoload.php';

$api = new \DigitalStars\SimpleAPI\SimpleAPI();
```

Файл user.php:

```php
require_once 'init.php';

$api->rootFilename(__FILE__);

$api->module('getUser', ['id:int'], function($data) {
    return ['user' => 'user' . $data['id']];
});
```

Зачем это нужно: SimpleAPI использует стек вызовов для обработки запросов. То есть, если запрос пришёл на файл user.php,
то SimpleAPI будет обрабатывать запросы только в этом файле. Если в этом файле вызывается модуль из файла info.php, то
SimpleAPI должен знать, какие модули регистрировать в файле info.php. Таким образом, можно разделить обработку запросов
на разные
файлы и вызывать модули из других файлов. Подробнее в
разделе [runModule](#runmodulestring-filename-string-module-array-data---arraystring).

## Свойства

### data: array

Массив параметров запроса. В него попадают все параметры, которые пришли в запросе. Включая параметры GET, POST и JSON.

### answer: array|string

Данные, которые будут отправлены клиенту. Может быть массивом или строкой. По умолчанию пустой массив.

### error_func: ?callable

Функция, которая будет вызвана при возникновении ошибки в любом из модулей. По умолчанию null.

### is_save_error: bool

Если true, то при возникновении ошибки, данные об ошибке будут сохранены в файле ошибок. По умолчанию false.

### is_ignore_destruct: bool

Если true, то при завершении скрипта, данные ответа не будут отправлены клиенту. По умолчанию false.
> Может быть полезно во время дебага, чтобы не отправлять клиенту недоработанный ответ. Или если нужно отправить ответ
> вручную с особыми заголовками.

### is_ignore_json_header: bool

Если true, то заголовок ответа не будет содержать "Content-Type: application/json", а также ответ не будет приводится к
JSON. По умолчанию false.

### is_log_time: bool

Если true, то в заголовке ответа будет добавлено поле "Server-Timing" с таймингами выполнения скрипта, модулей, и
кастомными таймерами. По умолчанию false.
Подробнее в разделе [Тайминги](#методы-для-таймингов)

### store: array

Массив, в который можно сохранять данные, чтобы использовать их в других модулях. По умолчанию пустой массив.

## Основные методы

### Конструктор или метод create

Метод create создаёт объект SimpleAPI.

Метод инициализации принимает необязательный параметр - время запуска скрипта с плавающей точкой (microtime(true)). По умолчанию - время создания объекта.

#### Пример

```php
$api = \DigitalStars\SimpleAPI\SimpleAPI::create(microtime(true));
// Или
$api = \DigitalStars\SimpleAPI\SimpleAPI::create();
// Или
$api = new \DigitalStars\SimpleAPI\SimpleAPI();
```

### rootFilename(string $filename): void

Устанавливает имя файла, в котором находится обработчик запросов. Нужно для вызова модулей из других файлов.
Он обязательно должен быть расположен **в начале файла, после всех подключений и до начала объявления модулей.**

### rawRootFilename(string $filename): void

То же самое что и метод выше, только в качестве параметра принимает название файла без расширения.

### module(string $name, array $params, callable $anon): void

Добавляет модуль в обработчик запросов. Модуль - это обработчик запросов, который может быть вызван клиентом.
Модуль может принимать на вход массив параметров и возвращать какие-то данные.

- $name - имя модуля (запрос обязательно должен иметь поле "module" с таким значением (не важно GET параметр, POST
  параметр или JSON поле)
- $params - массив параметров, которые принимает модуль. Может иметь типизированные или необязательные параметры (см.
  раздел [Валидация входных параметров](#валидация-входных-параметров))
- $anon - анонимная функция, которая принимает на вход массив параметров и возвращает какие-то данные

### close(): void

Закрывает соединение с клиентом. После вызова этого метода, данные ответа будут отправлены клиенту, но скрипт продолжит
своё
выполнение. Полезно, когда нужно отправить ответ клиенту и продолжить выполнение скрипта.

> **Внимание! После вызова этого метода, нельзя изменять данные ответа.**

> С помощью этого метода можно ускорить API, перенося сложные вычисления после отправки ответа клиенту.

#### Пример

```php
$api->module('getUsers', [], function() use ($api) {
    $api->answer['users'] = ['user1', 'user2'];
    $api->close();
    
    // Следующие строки будут выполнены после отправки ответа клиенту
    // ... Какие-то сложные расчёты, не влияющие на ответ клиенту
});
```

#### Примеры

```php
$api->module('getUsers', [], function() {
    return ['users' => ['user1', 'user2']];
});
```

Данный модуль будет обрабатывать запросы с параметром "module" равным "getUsers" и возвращать JSON массив с ключом "
users" и массивом пользователей.

```php
$api->module('getUser', ['id:int'], function($data) {
    return ['user' => 'user' . $data['id']];
});
```

Данный модуль будет обрабатывать запросы с параметром "module" равным "getUser" и параметром "id" типа int. Возвращать
будет JSON массив с ключом "user" и пользователем с id равным параметру "id". Если параметр "id" не будет передан или он
не будет являться числом, то будет возвращена ошибка.

```php
$api->module('getUser', ['id:int'], function($data) use ($api) {
    $api->answer['user'] = 'user' . $data['id'];
});
```

Данный модуль вернёт тот же результат, что и предыдущий, но возврат будет произведён через свойство $api->answer.

### runModule(string $filename, string $module, array $data = []): array|string

Вызывает модуль из файла. Возвращает результат выполнения модуля.

- $filename - имя файла, в котором находится модуль (без расширения)
- $module - имя модуля
- $data - массив параметров
- Возвращает результат выполнения модуля

#### Примеры

Файл user.php:

```php
$api->module('getUser', ['id:int'], function($data) {
    return ['user' => 'user' . $data['id']];
});

$api->module('getInfo', [], function($data) use ($api) {
    return $api->runModule('user', 'getUser', ['id' => 1]);
});
```

Модуль getInfo вызывает модуль getUser из файла user.php и возвращает результат выполнения.

> Внимание! При вызове модуля через runModule, можно вызвать только тот модуль, который был добавлен в обработчике.
> То есть, вызываемый модуль должен находиться выше вызывающего модуля.

Пример с вызовом модуля из другого файла:

init.php:

```php
require_once 'vendor/autoload.php';
$api = new \DigitalStars\SimpleAPI\SimpleAPI();
```

user.php:

```php
require_once 'init.php';

$api->rootFilename(__FILE__);

$api->module('getUser', ['id:int'], function($data) {
    return ['user_id' => $data['id'], 'name' => 'user_' . $data['id']'];
});
```

info.php:

```php
require_once 'init.php';

$api->rootFilename(__FILE__);

$api->module('getInfo', [], function($data) use ($api) {
    $user = $api->runModule('user', 'getUser', ['id' => 1]);
    return ['info' => 'info', 'user' => $user];
});
```

При запросе модуля getInfo из файла info.php, в процессе выполнения вызывается модуль getUser из файла user.php.

## Методы информационные

### isChildProcess(): bool

Возвращает true, если модуль был вызван через runModule, из другого модуля.

### getModule(): string

Возвращает имя текущего модуля, который сейчас выполняется (если выполняется дочерний модуль, то имя дочернего модуля)

### getFilename(): string

Возвращает имя файла, в котором находится текущий модуль (если выполняется дочерний модуль, то имя файла дочернего
модуля)

## Методы особых случаев

### addBeforeDestructFunc(callable $func): SimpleAPI

Добавляет функцию, которая будет вызвана перед отправкой ответа клиенту. В функцию передаётся объект SimpleAPI.
Полезно, если нужно выполнить какие-то действия перед отправкой ответа клиенту. (добавить какой-то заголовок, изменить
данные ответа)

> **Внимание!** При повторном вызове этого метода, будут добавлены новые функции, которые будут вызваны в порядке
> добавления.

### addAfterDestructFunc(callable $func): SimpleAPI

Добавляет функцию, которая будет вызвана после отправки ответа клиенту. В функцию передаётся объект SimpleAPI.
Полезно, если нужно выполнить какие-то действия после отправки ответа клиенту. (например залогировать запрос или ответ)

> **Внимание!** При повторном вызове этого метода, будут добавлены новые функции, которые будут вызваны в порядке
> добавления.

> Главное отличие от addBeforeDestructFunc в том, что эта функция будет вызвана после отправки ответа клиенту, но до
> завершения скрипта.
> То есть в ней нельзя менять данные ответа, но можно выполнить какие-то 'тяжёлые' действия.

## Валидация входных параметров

### Типы параметров

- int - целое число (или строка с целым числом)
- double - число с плавающей точкой (или строка с числом с плавающей точкой)
- bool - логическое значение (или строка "true" или "false") (любое значение, которое приводится к true или false)
- array - массив
- txt - строка, с экранированием HTML спецсимволов (htmlspecialchars)
- без типа данных - любой тип данных, без валидации (по умолчанию)

> Кроме того, в параметрах можно указать необязательные параметры, добавив знак вопроса перед названием параметра.

Значения по умолчанию для типов данных:

- int - null
- double - null
- bool - null
- array - []
- txt - null
- без типа данных - null

#### Примеры

```php
$api->module('getUser', ['id:int', 'name:txt', 'is_admin:bool', '?is_new_version:bool'], function($data) {
    return ['user' => 'user' . $data['id'], 'name' => $data['name'], 'is_admin' => $data['is_admin'], 'is_new_version' => $data['is_new_version']];
});
```

Данный модуль будет обрабатывать запросы с параметром "module" равным "getUser" и параметрами "id" типа int, "name" типа
txt, "is_admin" типа bool и "is_new_version" типа bool. Параметр "is_new_version" является необязательным.

#### Возвращаемое значение

Если параметры не валидны, то будет возвращена ошибка: "error" => "invalid_params".
Кроме того, в ответе будет поле "error_params" с массивом названий параметров, которые не прошли валидацию.

## Методы для валидации входных параметров

Для обработки крайних случаев, можно использовать методы для валидации входных параметров вручную.

### valid_int(string $field): SimpleAPI

Валидирует параметр как целое число. Если параметр не является целым числом, то добавляет ошибку в ответ.

### valid_double(string $field): SimpleAPI

Валидирует параметр как число с плавающей точкой. Если параметр не является числом с плавающей точкой, то добавляет ошибку в ответ.

### valid_bool(string $field): SimpleAPI

Валидирует параметр как логическое значение. Если параметр не является логическим значением, то добавляет ошибку в ответ.

### valid_array(string $field): SimpleAPI

Валидирует параметр как массив. Если параметр не является массивом, то добавляет ошибку в ответ.

### valid_preg(string $preg, string $field): SimpleAPI

Валидирует параметр с помощью регулярного выражения. Если параметр не соответствует регулярному выражению, то добавляет ошибку в ответ.

### field_invalid(string $field): SimpleAPI

Добавляет ошибку в ответ, что параметр не прошёл валидацию.

### validate(bool $is_send_exception = true): bool

Проверяет, если хотя бы один метод валидации вернул ошибку, то возвращает false. Иначе true. Кроме того, если параметр
$is_send_exception равен true, то при ошибке будет добавлена ошибка в ответ и выполнение скрипта будет прервано.

### error(string $text): void

Добавляет ошибку в ответ и немедленно завершает выполнение скрипта. $text - текст ошибки.

Текст ошибки будет добавлен в ответ в поле "error".

> Если вызван в дочернем модуле, то добавляет ошибку в ответ и возвращает управление родительскому модулю.

#### Примеры

```php

$api->module('getUser', ['id:int', 'name:txt', '?is_admin:bool'], function($data) use ($api) {
    $api->valid_preg('/^[a-zA-Z0-9_]+$/', 'name');
    $api->validate();
    
    return ['user' => 'user' . $data['id'], 'name' => $data['name'], 'is_admin' => $data['is_admin']];
});
```

Данный модуль будет обрабатывать запросы с параметром "module" равным "getUser" и параметрами "id" типа int, "name" типа
txt, "is_admin" типа bool. Параметр "name" будет валидирован с помощью регулярного выражения. Если параметры не
валидны, то будет возвращена ошибка: "error" => "invalid_params". Кроме того, в ответе будет поле "error_params" с
массивом названий параметров, которые не прошли валидацию.

Например, запрос:
```json
{
  "module": "getUser",
  "id": 1,
  "name": "User_123",
  "is_admin": true
}
```
Вернёт:
```
{
  "user": "user1",
  "name": "User_123",
  "is_admin": true
}
```

Запрос:
```json
{
  "module": "getUser",
  "id": 1,
  "name": "User_123!"
}
```
Вернёт:
```json
{
  "error": "invalid_params",
  "error_params": ["name"]
}
```

Запрос:
```json
{
  "module": "getUser",
  "id": "eee",
  "name": "User_123!!!!",
  "is_admin": true
}
```
Вернёт:
```json
{
  "error": "invalid_params",
  "error_params": ["id"]
}
```
> Обратите внимание, что параметра `name` нет в списке ошибок, потому что ошибка валидации параметра `id` прерывает
> выполнение модуля.

## Методы для таймингов

Библиотека поддеоживает тайминги выполнения скрипта, модулей и кастомные таймеры. Тайминги можно использовать для
оптимизации и дебага. Тайминги добавляются в заголовок ответа "Server-Timing" в формате "api;dur=123.45;desc=Script, ...."
(если свойство `is_log_time=true`).
Кроме того, тайминги можно получить через метод getTimerLog().

По умолчанию есть такие тайминги:

- Module - время выполнения модуля к которому пришёл запрос
- Script - время выполнения всего скрипта
- before_destruct_func_1, before_destruct_func_2, ... - время выполнения функций, добавленных через addBeforeDestructFunc
- subModule:filename:module - время выполнения модуля, вызванного через runModule

### getTimeStart(): float

Возвращает время начала выполнения скрипта (время в секундах с плавающей точкой)

### logTimer($name, $time_duration): void

Добавляет кастомный таймер. $name - название таймера, $time_duration - время выполнения таймера в секундах с плавающей

### timerStart(): float

Возвращает время начала выполнения таймера (время в секундах с плавающей точкой) (microtime(true))

### logTimerStop(string $name, float $time_start): float

Добавляет кастомный таймер. $name - название таймера, $time_start - время начала выполнения таймера (время в секундах с плавающей точкой) (microtime(true))

Возвращает время выполнения таймера в секундах с плавающей точкой

### getTimerLog(): array

Возвращает массив с таймингами выполнения скрипта, модулей и кастомными таймерами

Вид в котором они возвращаются:

```php
[
    ['Module', 0.123],
    ['Script', 0.456],
    ['before_destruct_func_1', 0.789],
    ['subModule:user:getUser', 0.123],
    ['custom_timer_1', 0.123],
    ...
]
```
